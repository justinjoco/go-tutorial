{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"This document is a how-to for developers on how to read and write Go code. Readers are assumed to know at least one or more coding languages. Through this document, developers should be able to read and write basic Go syntax and leverage some of Go\u2019s pseudo-OOP and concurrency features to write non-trivial programs. This document will also include links to repl.it, in which readers can run and change pre-existing Go code to further understand how to use it. Please leave your feedback here: https://forms.gle/zezZNmo7XGrq5xZZ6 . To raise an issue on Github for feature requests or bug fixes, go here: https://github.com/justinjoco/go-tutorial/issues What is the Go (Golang) language? Firstly, Go is a compiled programming language. To understand what this means, we must distinguish two times: compile time and run time. For a program to run, your code must be compiled (compile time), and the resulting executable should be ran (run time). Compile time: a \u201ccomplier\u201d translates your human-readable code into a machine-readable binary (or executable) file. Run time: The binary file is executed (or ran) by the machine to run your code\u2019s program. Secondly, Go is statically-typed, which means that your code\u2019s variables' data types must be known at compile time. This is to promote type safety, a language feature that restricts the amount of unknown states of your application or program that could potentially lead to unwanted, erroneous behavior. Compared to other languages, some say it is a \u201cbetter version of C\u201d because not only does Go generally perform very well in terms of speed and memory efficiency (similarly to other C languages), but it is also easy to read and write. In addition, Go has memory safety, garbage collection, and concurrency features not present in C. In fact, Go was developed by Google developers who didn\u2019t like C++, which is one of the earliest, most popular extensions of C. What applications are written in Go, and which companies use it? Applications Docker Community Edition, Compose-CLI, etc. InfluxDB: monitors computer performance metrics Kubernetes: orchestrates containers across multiple servers Companies Google Heroku Dropbox MongoDB Netflix Twitch Uber Why should I use Go? It has very good run-time performance, similar to that of C and C++ It is designed to be readable like Python or JS Its syntax is like combination of Python, TS, and C Go's concurrent programs are very easy to write It's very performant in networking and multiprocessing Go routines can be thought of as super lightweight threads It's easy to communicate between go routines via channels It's advised to use Go when developing scalable, high-performance applications What are some cons with using Go? There is no race condition safety; you need to use synchronization primitives (eg. sync package) Error handling is bare-bones No generics implementation yet Compile-time strictness can be annoying Not at lot of other in-built data structures besides arrays, slices, and maps Useful Links A Tour of Go: https://tour.golang.org/welcome/1 Go by Example: https://gobyexample.com/ Repl.it IDE: https://repl.it/ Golang Blog: https://blog.golang.org/","title":"Overview"},{"location":"#what-is-the-go-golang-language","text":"Firstly, Go is a compiled programming language. To understand what this means, we must distinguish two times: compile time and run time. For a program to run, your code must be compiled (compile time), and the resulting executable should be ran (run time). Compile time: a \u201ccomplier\u201d translates your human-readable code into a machine-readable binary (or executable) file. Run time: The binary file is executed (or ran) by the machine to run your code\u2019s program. Secondly, Go is statically-typed, which means that your code\u2019s variables' data types must be known at compile time. This is to promote type safety, a language feature that restricts the amount of unknown states of your application or program that could potentially lead to unwanted, erroneous behavior. Compared to other languages, some say it is a \u201cbetter version of C\u201d because not only does Go generally perform very well in terms of speed and memory efficiency (similarly to other C languages), but it is also easy to read and write. In addition, Go has memory safety, garbage collection, and concurrency features not present in C. In fact, Go was developed by Google developers who didn\u2019t like C++, which is one of the earliest, most popular extensions of C.","title":"What is the Go (Golang) language?"},{"location":"#what-applications-are-written-in-go-and-which-companies-use-it","text":"Applications Docker Community Edition, Compose-CLI, etc. InfluxDB: monitors computer performance metrics Kubernetes: orchestrates containers across multiple servers Companies Google Heroku Dropbox MongoDB Netflix Twitch Uber","title":"What applications are written in Go, and which companies use it?"},{"location":"#why-should-i-use-go","text":"It has very good run-time performance, similar to that of C and C++ It is designed to be readable like Python or JS Its syntax is like combination of Python, TS, and C Go's concurrent programs are very easy to write It's very performant in networking and multiprocessing Go routines can be thought of as super lightweight threads It's easy to communicate between go routines via channels It's advised to use Go when developing scalable, high-performance applications","title":"Why should I use Go?"},{"location":"#what-are-some-cons-with-using-go","text":"There is no race condition safety; you need to use synchronization primitives (eg. sync package) Error handling is bare-bones No generics implementation yet Compile-time strictness can be annoying Not at lot of other in-built data structures besides arrays, slices, and maps","title":"What are some cons with using Go?"},{"location":"#useful-links","text":"A Tour of Go: https://tour.golang.org/welcome/1 Go by Example: https://gobyexample.com/ Repl.it IDE: https://repl.it/ Golang Blog: https://blog.golang.org/","title":"Useful Links"},{"location":"basics/building/","text":"Building and Running Go Code To run Go code, you need to do the following: Download Go from https://golang.org/ Create a source code directory and input your Go code in there, with extension .go Ways to run code Running one Go file: two ways Use go build <filename> then run ./<filename> to run Go executable Use go run <filename> to build and run code in one command Running a Go source directory Be in the directory one above the Go source directory Run go build -o <output-executable> <source-directory> , in which <output-exectuable> is your custom name of the Go executable Run ./<output-executable> <args> , in which <args> are potential input arguments to executable Hello World Sample code link: ( https://repl.it/@jjoco/go-hello-world ) To create a \"Hello World\" program, you need a main function, like other C-like languages. Take the following example: 1 2 3 4 5 6 7 package main import \"fmt\" func main (){ fmt . Println ( \"Hello World\" ) } Notes The first statement in a Go source file must be package name. Executable commands must always use package main. Use fmt package in order to print out strings to the console. Here are some important functions: fmt.Println(... args) : prints a list of variables to STDOUT with default formatting and inserts spaces between the variables and appends a new line at the end. fmt.Printf(stringFormat, fields) : allows you to specify the formatting using a format template","title":"Running Go Programs"},{"location":"basics/building/#building-and-running-go-code","text":"To run Go code, you need to do the following: Download Go from https://golang.org/ Create a source code directory and input your Go code in there, with extension .go Ways to run code Running one Go file: two ways Use go build <filename> then run ./<filename> to run Go executable Use go run <filename> to build and run code in one command Running a Go source directory Be in the directory one above the Go source directory Run go build -o <output-executable> <source-directory> , in which <output-exectuable> is your custom name of the Go executable Run ./<output-executable> <args> , in which <args> are potential input arguments to executable","title":"Building and Running Go Code"},{"location":"basics/building/#hello-world","text":"Sample code link: ( https://repl.it/@jjoco/go-hello-world ) To create a \"Hello World\" program, you need a main function, like other C-like languages. Take the following example: 1 2 3 4 5 6 7 package main import \"fmt\" func main (){ fmt . Println ( \"Hello World\" ) } Notes The first statement in a Go source file must be package name. Executable commands must always use package main. Use fmt package in order to print out strings to the console. Here are some important functions: fmt.Println(... args) : prints a list of variables to STDOUT with default formatting and inserts spaces between the variables and appends a new line at the end. fmt.Printf(stringFormat, fields) : allows you to specify the formatting using a format template","title":"Hello World"},{"location":"basics/conditionals/","text":"Sample code link: ( https://repl.it/@jjoco/go-conditionals ) Traditional If, Else-If, Else Statements Like all other programming languages, Go has traditional if-else statements; the main difference is the lack of parentheses around the condition: Syntax 1 2 3 4 5 6 7 if condition { //Do stuff in first condition ... } else if otherCondition { //Do stuff in otherCondition... } else { //Do stuff if none of the above is satisfied ... } Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 count := 6 if count < 10 { fmt . Printf ( \"Count is below 10 at value %d\\n\" , count ) } // Output = \"Count is below 10 at value 6\" count = 51 if count % 2 == 0 { fmt . Printf ( \"Count is even!\\n\" ) } else { fmt . Printf ( \"Count is odd!\\n\" ) } //Output = \"Count is odd!\" count = 25 if count % 15 == 0 { fmt . Printf ( \"FizzBuzz\\n\" ) } else if count % 5 == 0 { fmt . Printf ( \"Buzz\\n\" ) } else if count % 3 == 0 { fmt . Printf ( \"Fizz\\n\" ) } else { fmt . Printf ( \"NoneOfTheAbove\\n\" ) } //Output = \"Buzz\" In the above example, we check to see if a count is divsible by a certain number, and the respective case is executed. If with Short Assignment In Go, the user can assign a variable and condition on that variable on the same line (separated by a : ), like the following 1 2 3 4 if shortStatementInt := 32 ; shortStatementInt > 30 { fmt . Printf ( \"shortStatementInt is above 30!\\n\" ) } //Output = \"shortStatementInt is above 30!\" In the above example, shortStatementInt is assigned, then evaluated in the condition following the :","title":"Conditionals"},{"location":"basics/conditionals/#traditional-if-else-if-else-statements","text":"Like all other programming languages, Go has traditional if-else statements; the main difference is the lack of parentheses around the condition: Syntax 1 2 3 4 5 6 7 if condition { //Do stuff in first condition ... } else if otherCondition { //Do stuff in otherCondition... } else { //Do stuff if none of the above is satisfied ... } Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 count := 6 if count < 10 { fmt . Printf ( \"Count is below 10 at value %d\\n\" , count ) } // Output = \"Count is below 10 at value 6\" count = 51 if count % 2 == 0 { fmt . Printf ( \"Count is even!\\n\" ) } else { fmt . Printf ( \"Count is odd!\\n\" ) } //Output = \"Count is odd!\" count = 25 if count % 15 == 0 { fmt . Printf ( \"FizzBuzz\\n\" ) } else if count % 5 == 0 { fmt . Printf ( \"Buzz\\n\" ) } else if count % 3 == 0 { fmt . Printf ( \"Fizz\\n\" ) } else { fmt . Printf ( \"NoneOfTheAbove\\n\" ) } //Output = \"Buzz\" In the above example, we check to see if a count is divsible by a certain number, and the respective case is executed.","title":"Traditional If, Else-If, Else Statements"},{"location":"basics/conditionals/#if-with-short-assignment","text":"In Go, the user can assign a variable and condition on that variable on the same line (separated by a : ), like the following 1 2 3 4 if shortStatementInt := 32 ; shortStatementInt > 30 { fmt . Printf ( \"shortStatementInt is above 30!\\n\" ) } //Output = \"shortStatementInt is above 30!\" In the above example, shortStatementInt is assigned, then evaluated in the condition following the :","title":"If with Short Assignment"},{"location":"basics/errors/","text":"Sample code link: ( https://repl.it/@jjoco/go-error-handling ) Some functions return an error type 1 2 3 4 sampleVar , err := canReturnErrorFct ( args ) if err != nil { //Do something if there's an error } If the function is successful, err would be nil. Example 1 2 3 4 5 6 7 8 9 10 sampleStr := \"ffgds\" strToInt , err := strconv . Atoi ( sampleStr ) if err != nil { log . Fatal ( err ) } fmt . Println ( strToInt ) // Output = \"2020/10/22 19:39:38 strconv.Atoi: parsing \"ffgds\": invalid syntax\" // \"exit status 1\" Ignoring errors If you're feeling ambitious, you can certainly skip error handling of a function like below using _ : 1 sampleVar , _ := canReturnErrorFct ( args ) However, only do this if you're really confident that the function will not return an error ever","title":"Error Handling"},{"location":"basics/functions/","text":"Sample code link: ( https://repl.it/@jjoco/go-functions ) Declaring Functions Go's function declaration uses the func keyword, and the dev can specify input and output parameter types. 1 2 3 func functionName ( arg0 Arg1Type , ... , argN ArgNType ) ReturnType { //Function code goes here... } Syntax notes: function => func No colons between variable name and its type Example: Get hypotenuse of triangle given leg lengths 1 2 3 4 func getHypotenuse ( x float64 , y float64 ) float64 { return math . Sqrt ( math . Pow ( x , 2 ) + math . Pow ( y , 2 )) } // Output of getHypotenuse(3, 4) = 5 Defer The defer keyword is used to run a statement after the current function has returned. You might want to use this if, for example, you had a port listener and you wanted to close it after a function returns. Sample usage: 1 2 3 4 5 6 func testDefer (){ defer fmt . Println ( \"Called after testDefer() returns\" ) fmt . Println ( \"Called during testDefer() call\" ) } //Output = \"Called during testDefer() call\" // \"Called after testDefer() returns\" Variadic Functions You can define a function to have a variable amount of arguments (of the same type) like the following: 1 2 3 4 5 6 7 func sum ( numbers ... int ) int { total := 0 for _ , number := range numbers { total += number } return total } The above function can have two or more integers as parameters, and the function would work fine. This allows functions like append to have a variable amount of elements to add into a slice. In calling function: 1 2 3 numbers := [] int { 1 , 2 , 3 , 4 , 5 , 6 } fmt . Println ( sum ( numbers ... )) // Output = \"21\" Use ...elementType in function signature to denote a varying amount of arguments of elementType Use elementArr... to unpack the elements in elementArr into function's input","title":"Functions"},{"location":"basics/functions/#declaring-functions","text":"Go's function declaration uses the func keyword, and the dev can specify input and output parameter types. 1 2 3 func functionName ( arg0 Arg1Type , ... , argN ArgNType ) ReturnType { //Function code goes here... } Syntax notes: function => func No colons between variable name and its type Example: Get hypotenuse of triangle given leg lengths 1 2 3 4 func getHypotenuse ( x float64 , y float64 ) float64 { return math . Sqrt ( math . Pow ( x , 2 ) + math . Pow ( y , 2 )) } // Output of getHypotenuse(3, 4) = 5","title":"Declaring Functions"},{"location":"basics/functions/#defer","text":"The defer keyword is used to run a statement after the current function has returned. You might want to use this if, for example, you had a port listener and you wanted to close it after a function returns. Sample usage: 1 2 3 4 5 6 func testDefer (){ defer fmt . Println ( \"Called after testDefer() returns\" ) fmt . Println ( \"Called during testDefer() call\" ) } //Output = \"Called during testDefer() call\" // \"Called after testDefer() returns\"","title":"Defer"},{"location":"basics/functions/#variadic-functions","text":"You can define a function to have a variable amount of arguments (of the same type) like the following: 1 2 3 4 5 6 7 func sum ( numbers ... int ) int { total := 0 for _ , number := range numbers { total += number } return total } The above function can have two or more integers as parameters, and the function would work fine. This allows functions like append to have a variable amount of elements to add into a slice. In calling function: 1 2 3 numbers := [] int { 1 , 2 , 3 , 4 , 5 , 6 } fmt . Println ( sum ( numbers ... )) // Output = \"21\" Use ...elementType in function signature to denote a varying amount of arguments of elementType Use elementArr... to unpack the elements in elementArr into function's input","title":"Variadic Functions"},{"location":"basics/import/","text":"We can import packages into the current Go file. Importing One Package To import a package, use double quotes, like the following: 1 import \"packageName\" Importing Multiple Packages To import multiple packages at once, encapsulate the list of packages in parentheses, and separate packages by newlines. 1 2 3 4 5 6 7 8 import ( \"package1\" \"package2\" . . . \"packageN\" ) Package Aliasing If the developer prefers not to use the package's full name, the dev can alias package names : 1 2 3 4 import ( alias1 \"package1\" alias2 \"package2\" ) Useful Packages I've compiled a list of packages that I found useful for various Go projects I've contributed to: General utility strconv : converts numeric types (bools, ints, floats, etc.) and certain strings types to and from ASCII strings fmt : \"implements formatted I/O with functions analogous to C's printf and scanf. The format 'verbs' are derived from C's but are simpler.\" time : \"provides functionality for measuring and displaying time\" sync \"provides basic synchronization primitives such as mutual exclusion locks. \" strings : \"implements simple functions to manipulate UTF-8 encoded strings.\" Testing testing : \"provides support for automated testing of Go packages. It is intended to be used in concert with the go test command, which automates Go unit testing\" github.com/stretchr/testify/suite : \"provides [testing] functionality that you might be used to from more common object oriented languages. With it, you can build a testing suite as a struct, build setup/teardown methods and testing methods on your struct, and run them with go test as per normal\" File I/O bufio : \"implements buffered I/O. It wraps an io.Reader or io.Writer object, creating another object (Reader or Writer) that also implements the interface but provides buffering and some help for textual I/O.\" os : \"provides a platform-independent interface to operating system functionality\" Networking net : \"provides a portable interface for network I/O, including TCP/IP, UDP, domain name resolution, and Unix domain sockets\" net/http : \"provides HTTP client and server implementations.\" github.com/gorilla/mux : \"implements a request router and dispatcher for matching incoming requests to their respective handler.\"","title":"Importing Packages"},{"location":"basics/import/#importing-one-package","text":"To import a package, use double quotes, like the following: 1 import \"packageName\"","title":"Importing One Package"},{"location":"basics/import/#importing-multiple-packages","text":"To import multiple packages at once, encapsulate the list of packages in parentheses, and separate packages by newlines. 1 2 3 4 5 6 7 8 import ( \"package1\" \"package2\" . . . \"packageN\" )","title":"Importing Multiple Packages"},{"location":"basics/import/#package-aliasing","text":"If the developer prefers not to use the package's full name, the dev can alias package names : 1 2 3 4 import ( alias1 \"package1\" alias2 \"package2\" )","title":"Package Aliasing"},{"location":"basics/import/#useful-packages","text":"I've compiled a list of packages that I found useful for various Go projects I've contributed to: General utility strconv : converts numeric types (bools, ints, floats, etc.) and certain strings types to and from ASCII strings fmt : \"implements formatted I/O with functions analogous to C's printf and scanf. The format 'verbs' are derived from C's but are simpler.\" time : \"provides functionality for measuring and displaying time\" sync \"provides basic synchronization primitives such as mutual exclusion locks. \" strings : \"implements simple functions to manipulate UTF-8 encoded strings.\" Testing testing : \"provides support for automated testing of Go packages. It is intended to be used in concert with the go test command, which automates Go unit testing\" github.com/stretchr/testify/suite : \"provides [testing] functionality that you might be used to from more common object oriented languages. With it, you can build a testing suite as a struct, build setup/teardown methods and testing methods on your struct, and run them with go test as per normal\" File I/O bufio : \"implements buffered I/O. It wraps an io.Reader or io.Writer object, creating another object (Reader or Writer) that also implements the interface but provides buffering and some help for textual I/O.\" os : \"provides a platform-independent interface to operating system functionality\" Networking net : \"provides a portable interface for network I/O, including TCP/IP, UDP, domain name resolution, and Unix domain sockets\" net/http : \"provides HTTP client and server implementations.\" github.com/gorilla/mux : \"implements a request router and dispatcher for matching incoming requests to their respective handler.\"","title":"Useful Packages"},{"location":"basics/looping/","text":"Sample code link: ( https://repl.it/@jjoco/go-looping ) Traditional For-Looping Like many other languages, Go supports traditional for-looping. The caveat is the lack of parentheses around the for statements Syntax 1 2 3 for i := start ; i < end ; i += increment { //Do stuff each iteration } 1 2 3 4 5 factorial := 1 for i := 1 ; i <= 5 ; i ++ { factorial *= i } //Output = \"5! = 120\" \"While\" For-Loops Unlike many other languages, Go does not have while loops; instead, for loops can be used to replace while loops by using the following syntax. Syntax 1 2 3 for condition { //Do stuff each iteration } - while (condition) => for condition with no parentheses around condition Example: 1 2 3 4 5 accumulator := 0 for accumulator < 10 { accumulator += 1 } // Output = \"Accumulator at end of while for-loop: 10\" Infinite Loops Even though there are no while loops in Go, a developer can write infinite loops by using a for loop with no condition, like the following: Syntax 1 2 3 for { // Code that runs on each iteration goes here... } Example: Reads user input in terminal, forever 1 2 3 4 5 6 7 8 //Imports \"bufio\" and \"os\" packages to parse and read user input in terminal reader := bufio . NewReader ( os . Stdin ) fmt . Printf ( \"Testing Infinite Looping... \\n\" ) fmt . Printf ( \"-------------\\n\" ) for { text , _ := reader . ReadString ( '\\n' ) fmt . Printf ( \"Text entered: %s\\n\" , text ) }","title":"Looping"},{"location":"basics/looping/#traditional-for-looping","text":"Like many other languages, Go supports traditional for-looping. The caveat is the lack of parentheses around the for statements Syntax 1 2 3 for i := start ; i < end ; i += increment { //Do stuff each iteration } 1 2 3 4 5 factorial := 1 for i := 1 ; i <= 5 ; i ++ { factorial *= i } //Output = \"5! = 120\"","title":"Traditional For-Looping"},{"location":"basics/looping/#while-for-loops","text":"Unlike many other languages, Go does not have while loops; instead, for loops can be used to replace while loops by using the following syntax. Syntax 1 2 3 for condition { //Do stuff each iteration } - while (condition) => for condition with no parentheses around condition Example: 1 2 3 4 5 accumulator := 0 for accumulator < 10 { accumulator += 1 } // Output = \"Accumulator at end of while for-loop: 10\"","title":"\"While\" For-Loops"},{"location":"basics/looping/#infinite-loops","text":"Even though there are no while loops in Go, a developer can write infinite loops by using a for loop with no condition, like the following: Syntax 1 2 3 for { // Code that runs on each iteration goes here... } Example: Reads user input in terminal, forever 1 2 3 4 5 6 7 8 //Imports \"bufio\" and \"os\" packages to parse and read user input in terminal reader := bufio . NewReader ( os . Stdin ) fmt . Printf ( \"Testing Infinite Looping... \\n\" ) fmt . Printf ( \"-------------\\n\" ) for { text , _ := reader . ReadString ( '\\n' ) fmt . Printf ( \"Text entered: %s\\n\" , text ) }","title":"Infinite Loops"},{"location":"basics/pointers/","text":"Sample code link: ( https://repl.it/@jjoco/go-pointers ) Pointers essentially points to a place in memory that stores a variable of type T (ie memory address). This is similar to pointers used in C-like languages. Regular vs. Short Assignment One can define pointers via regular or short assigning, like any other variable. Dereferencing them is identical to that of other languages, eg if iPtr is a pointer, *iPtr dereferences it. Regular 1 2 3 4 5 6 7 var iPtr * int i := 42 iPtr = & i fmt . Println ( * iPtr ) //Output = \"42\" Short Assignment 1 2 3 4 5 j := 24 jPtr := & j fmt . Println ( * jPtr ) // Output = \"24\" Pass by Value vs. Pass By Pointer If you intend to change the input variable to a function and have the change be visible from the caller, use pointers. Pass by Value 1 2 3 4 //Doubles input func doubleByValue ( x int ) { x *= 2 } 1 2 3 4 /*Pass By Value Call*/ k := 32 doubleByValue ( k ) //Output = \"After Pass By Value call: 32\" Pass by Pointer 1 2 3 4 //Doubles input func doubleByPointer ( xPtr * int ) { * xPtr *= 2 } 1 2 3 4 /*Pass by Pointer Call*/ l := 32 doubleByPointer ( & l ) //Output = \"After Pass By Pointer call: 64\" From the above, note that in the Pass By Value case, a copy of k is passed into doubleByValue, instead of k itself; as a result, the main function does not observe k changing. However, in the Pass By Pointer case, the address of l is passed into doubleByPointer, which doubles the integer that is stored in that memory address. As a result, the main function observes l double. Pointers to Pointers A developer can set a variable to be pointers to other pointers. For example, if I want to make a pointer to a pointer (double pointer), one can declare var doublePointer **int . It follows that one can declare a triple pointer (pointer to a double pointer) like var triplePointer ***int , and so on and so forth.","title":"Pointers"},{"location":"basics/pointers/#regular-vs-short-assignment","text":"One can define pointers via regular or short assigning, like any other variable. Dereferencing them is identical to that of other languages, eg if iPtr is a pointer, *iPtr dereferences it. Regular 1 2 3 4 5 6 7 var iPtr * int i := 42 iPtr = & i fmt . Println ( * iPtr ) //Output = \"42\" Short Assignment 1 2 3 4 5 j := 24 jPtr := & j fmt . Println ( * jPtr ) // Output = \"24\"","title":"Regular vs. Short Assignment"},{"location":"basics/pointers/#pass-by-value-vs-pass-by-pointer","text":"If you intend to change the input variable to a function and have the change be visible from the caller, use pointers. Pass by Value 1 2 3 4 //Doubles input func doubleByValue ( x int ) { x *= 2 } 1 2 3 4 /*Pass By Value Call*/ k := 32 doubleByValue ( k ) //Output = \"After Pass By Value call: 32\" Pass by Pointer 1 2 3 4 //Doubles input func doubleByPointer ( xPtr * int ) { * xPtr *= 2 } 1 2 3 4 /*Pass by Pointer Call*/ l := 32 doubleByPointer ( & l ) //Output = \"After Pass By Pointer call: 64\" From the above, note that in the Pass By Value case, a copy of k is passed into doubleByValue, instead of k itself; as a result, the main function does not observe k changing. However, in the Pass By Pointer case, the address of l is passed into doubleByPointer, which doubles the integer that is stored in that memory address. As a result, the main function observes l double.","title":"Pass by Value vs. Pass By Pointer"},{"location":"basics/pointers/#pointers-to-pointers","text":"A developer can set a variable to be pointers to other pointers. For example, if I want to make a pointer to a pointer (double pointer), one can declare var doublePointer **int . It follows that one can declare a triple pointer (pointer to a double pointer) like var triplePointer ***int , and so on and so forth.","title":"Pointers to Pointers"},{"location":"basics/switch/","text":"Sample code link: ( https://repl.it/@jjoco/go-switch-case ) Like C-like langauges and TS, Go supports switch-case statements, configured with or without an expression to evaluate cases: Switch with Expression Syntax 1 2 3 4 5 6 7 8 9 10 11 12 13 switch expression { case x : // Do in case x... case y : // Do in case y... case z : // Do in case z... . . . default : //Do when no other case is satisfied ... } Syntax notes No break after each case No parentheses around expression Example: 1 2 3 4 5 6 7 8 9 10 11 12 color := \"red\" switch color { case \"green\" : fmt . Println ( \"Go\" ) case \"yellow\" : fmt . Println ( \"Slow\" ) default : fmt . Println ( \"Stop\" ) } //Output = \"Stop\" Switch used as a Long If-Else Like switch(true) in other languages, using switch in Go without an expression can be used as a cleaner if-else statement, especially with many conditions. Syntax 1 2 3 4 5 6 7 8 9 10 11 12 13 14 switch { case condition1 : ... case condition2 : ... case condition3 : ... . . . default : ... } Syntax notes: No break after each case No true expression needed in switch Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 grade := 71 letterGrade := \"\" switch { case grade > 90 : letterGrade = \"A\" case grade > 80 : letterGrade = \"B\" case grade > 70 : letterGrade = \"C\" case grade > 65 : letterGrade = \"D\" default : letterGrade = \"F\" } fmt . Printf ( \"Your grade is %s\\n\" , letterGrade ) //Output = \"Your grade is C\"","title":"Switch-Case"},{"location":"basics/switch/#switch-with-expression","text":"Syntax 1 2 3 4 5 6 7 8 9 10 11 12 13 switch expression { case x : // Do in case x... case y : // Do in case y... case z : // Do in case z... . . . default : //Do when no other case is satisfied ... } Syntax notes No break after each case No parentheses around expression Example: 1 2 3 4 5 6 7 8 9 10 11 12 color := \"red\" switch color { case \"green\" : fmt . Println ( \"Go\" ) case \"yellow\" : fmt . Println ( \"Slow\" ) default : fmt . Println ( \"Stop\" ) } //Output = \"Stop\"","title":"Switch with Expression"},{"location":"basics/switch/#switch-used-as-a-long-if-else","text":"Like switch(true) in other languages, using switch in Go without an expression can be used as a cleaner if-else statement, especially with many conditions. Syntax 1 2 3 4 5 6 7 8 9 10 11 12 13 14 switch { case condition1 : ... case condition2 : ... case condition3 : ... . . . default : ... } Syntax notes: No break after each case No true expression needed in switch Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 grade := 71 letterGrade := \"\" switch { case grade > 90 : letterGrade = \"A\" case grade > 80 : letterGrade = \"B\" case grade > 70 : letterGrade = \"C\" case grade > 65 : letterGrade = \"D\" default : letterGrade = \"F\" } fmt . Printf ( \"Your grade is %s\\n\" , letterGrade ) //Output = \"Your grade is C\"","title":"Switch used as a Long If-Else"},{"location":"basics/vars/","text":"Sample code link: https://repl.it/@jjoco/go-variables-and-assignment Primitive Types Like other programming languages, Go has primitive data types: Boolean: bool String: string Signed Integers: int, int8, int16, int32, int64 Unsigned integers: uint, uint8, uint16, uint32, uint64 Byte : byte => alias for uint8 Rune: rune => alias for int32 Floats: float32, float64 Complex numbers: complex64, complex128 Void is not a type Note: int and uint \"are usually 32 bits wide on 32-bit systems and 64 bits wide on 64-bit systems\" Regular Assignment At compile time, the developer can specify the type of the variable declared using the var keyword. As an FYI, Go's variable naming convention is camelCase . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var notAssignedInt int fmt . Printf ( \"Not assigned int: %d\\n\" , notAssignedInt ) //%d decimal //Output = \"Not assigned int: 0\" var notAssignedVar fmt . Println ( \"Not assigned var: \" , notAssignedVar ) //Compile error => type is not defined for \"notAssignedVar\" var assignedBool1 bool = true fmt . Printf ( \"Assigned bool = %t\\n\" , assignedBool1 ) //%t boolean value //Output = \"Assigned bool = true\" var assignedBool2 = false fmt . Printf ( \"Assigned bool = %t\\n\" , assignedBool2 ) //%t boolean value //Output = \"Assigned bool = false\" Important notes: Only var is used when creating a new variable No colons when specifying a variable's type Uninitialized variables are set to their default \"zero\" value: Number types (eg ints, unsigned ints, floats, etc.) are set to 0 Boolean types are set to false String types are set to empty strings \"\" Short Assignment Developers can directly assign a literal to a variable using := , and the compiler will infer what type of variable it is based on what was assigned. 1 2 3 shortAssignedString := \"short\" fmt . Printf ( \"Short assigned string: %s\\n\" , shortAssignedString ) //%s string //Output= \"Short assigned string: short\" Multiple Assignments Similar to other languages, the developer can assign multiple variables at once using regular or short assigning. 1 2 3 4 5 var multAssignedInt1 , multAssignedInt2 = 3 , 4 // Output: \"multAssignedInt1 = 3, multAssignedInt2 = 4\" shortAssignedString1 , shortAssignedString2 := \"hello\" , \"world\" // Output: \"shortAssignedString1 = hello, shortAssignedString2 = world\" Constants Constants can be assigned via the const keyword, and camelCase is generally used as the naming convention; PascalCase when exporting a const. 1 2 const ConstantNumber = 10 // Output = \"Constant Number: 10\" Unfortunately, constants cannot be assigned via := short assignment syntax Operators Golang supports the same arithmetic, comparison, logical, bitwise, and assignment operators as other C-like languages. They are listed below. Arithmetic + Addition - Subtraction * Multiplication / Divison % Modulus ++ Increment by 1 -- Decrement by 1 Comparison < Less than > Greater than <= Less than or equal to >= Greater than or equal to == Equal to != Not equal to Logical && Conditional AND || Conditional OR ! NOT Assignment += add, then assign -= subtract, then assign *= multiply, then assign /= divide, then assign %= modulo, then assign Bitwise & Bitwise AND | Bitwise OR ^ Bitwise XOR << Left shift >> Right shift","title":"Variables and Assignments"},{"location":"basics/vars/#primitive-types","text":"Like other programming languages, Go has primitive data types: Boolean: bool String: string Signed Integers: int, int8, int16, int32, int64 Unsigned integers: uint, uint8, uint16, uint32, uint64 Byte : byte => alias for uint8 Rune: rune => alias for int32 Floats: float32, float64 Complex numbers: complex64, complex128 Void is not a type Note: int and uint \"are usually 32 bits wide on 32-bit systems and 64 bits wide on 64-bit systems\"","title":"Primitive Types"},{"location":"basics/vars/#regular-assignment","text":"At compile time, the developer can specify the type of the variable declared using the var keyword. As an FYI, Go's variable naming convention is camelCase . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var notAssignedInt int fmt . Printf ( \"Not assigned int: %d\\n\" , notAssignedInt ) //%d decimal //Output = \"Not assigned int: 0\" var notAssignedVar fmt . Println ( \"Not assigned var: \" , notAssignedVar ) //Compile error => type is not defined for \"notAssignedVar\" var assignedBool1 bool = true fmt . Printf ( \"Assigned bool = %t\\n\" , assignedBool1 ) //%t boolean value //Output = \"Assigned bool = true\" var assignedBool2 = false fmt . Printf ( \"Assigned bool = %t\\n\" , assignedBool2 ) //%t boolean value //Output = \"Assigned bool = false\" Important notes: Only var is used when creating a new variable No colons when specifying a variable's type Uninitialized variables are set to their default \"zero\" value: Number types (eg ints, unsigned ints, floats, etc.) are set to 0 Boolean types are set to false String types are set to empty strings \"\"","title":"Regular Assignment"},{"location":"basics/vars/#short-assignment","text":"Developers can directly assign a literal to a variable using := , and the compiler will infer what type of variable it is based on what was assigned. 1 2 3 shortAssignedString := \"short\" fmt . Printf ( \"Short assigned string: %s\\n\" , shortAssignedString ) //%s string //Output= \"Short assigned string: short\"","title":"Short Assignment"},{"location":"basics/vars/#multiple-assignments","text":"Similar to other languages, the developer can assign multiple variables at once using regular or short assigning. 1 2 3 4 5 var multAssignedInt1 , multAssignedInt2 = 3 , 4 // Output: \"multAssignedInt1 = 3, multAssignedInt2 = 4\" shortAssignedString1 , shortAssignedString2 := \"hello\" , \"world\" // Output: \"shortAssignedString1 = hello, shortAssignedString2 = world\"","title":"Multiple Assignments"},{"location":"basics/vars/#constants","text":"Constants can be assigned via the const keyword, and camelCase is generally used as the naming convention; PascalCase when exporting a const. 1 2 const ConstantNumber = 10 // Output = \"Constant Number: 10\" Unfortunately, constants cannot be assigned via := short assignment syntax","title":"Constants"},{"location":"basics/vars/#operators","text":"Golang supports the same arithmetic, comparison, logical, bitwise, and assignment operators as other C-like languages. They are listed below. Arithmetic + Addition - Subtraction * Multiplication / Divison % Modulus ++ Increment by 1 -- Decrement by 1 Comparison < Less than > Greater than <= Less than or equal to >= Greater than or equal to == Equal to != Not equal to Logical && Conditional AND || Conditional OR ! NOT Assignment += add, then assign -= subtract, then assign *= multiply, then assign /= divide, then assign %= modulo, then assign Bitwise & Bitwise AND | Bitwise OR ^ Bitwise XOR << Left shift >> Right shift","title":"Operators"},{"location":"collections/maps/","text":"Sample code link: ( https://repl.it/@jjoco/go-maps ) Go implements map, a key-value data structure similar to Dictionaries in Python and Hashtables/HashMaps in Java. Creating a Map A dev can use literal-based syntax or the make function to allocate memory for a new map. 1 2 3 4 5 6 7 exampleMap := make ( map [ KeyType ] ValueType ) //Functionally identical to using the make function otherExampleMap := map [ KeyType ] ValueType {} //Use interface{} if the ValueType can be anything anyValueMap := make ( map [ string ] interface {}) KeyType must be a type that is comparable => \"boolean, numeric, string, pointer, channel, and interface types, and structs or arrays that contain only those types\" ValueType can be of any type, including custom structs or other maps use interface{} as your ValueType to have the map's valueType be of anything Reading and Writing Map Elements Like other languages, one can directly read, write, and delete values from Go maps. 1 2 3 4 5 6 7 //Setting Map Elements cardMap [ \"ace\" ] = 1 cardMap [ \"jack\" ] = 11 cardMap [ \"queen\" ] = 12 cardMap [ \"king\" ] = 13 // cardMap == map[ace:1 jack:11 king:13 queen:12] Reading Map Element 1 2 j := cardMap [ \"queen\" ] // j == 12 Deleting Map Element 1 2 delete ( cardMap , \"king\" ) // cardMap == map[ace:1 jack:11 queen:12] Map Literals Use map literals to define the initial elements in a map. 1 2 3 4 5 trafficLightMap := map [ string ] string { \"red\" : \"stop\" , \"green\" : \"go\" , \"yellow\" : \"slow\" , } Iterating Through Maps Similar in syntax to slice iteration, a dev can use range to iterate through the key-value pairs in a map. 1 2 3 for key , value := range exampleMap { //Process key and/or value } Can use _ in place of key or value if they aren't needed Example: 1 2 3 4 5 6 7 8 9 for key , value := range cardMap { fmt . Println ( \"Key:\" , key , \"; Value:\" , value ) } /* Console output Key: ace ; Value: 1 Key: jack ; Value: 11 Key: queen ; Value: 12 */ Getting a Key's Value if the pair exists There is an optional second return value when reading from a map that tells the dev if a key-value pair exists. Syntax 1 2 3 4 5 value , ok := someMap [ key ] if ! ok { //Do something if there is no key-value pair } Checking for key-value existence If you don't care for retrieving the value, one can just check the existence of the key-value pair. 1 2 3 4 5 _ , ok := someMap [ key ] if ! ok { //Do something if there is no key-value pair } Example: 1 2 3 4 5 6 7 //Given: \"king\" and its value don't exist in cardMap k , ok := cardMap [ \"king\" ] if ! ok { fmt . Println ( \"king isn't there\" ) } //Output = \"king isn't there\"","title":"Maps"},{"location":"collections/maps/#creating-a-map","text":"A dev can use literal-based syntax or the make function to allocate memory for a new map. 1 2 3 4 5 6 7 exampleMap := make ( map [ KeyType ] ValueType ) //Functionally identical to using the make function otherExampleMap := map [ KeyType ] ValueType {} //Use interface{} if the ValueType can be anything anyValueMap := make ( map [ string ] interface {}) KeyType must be a type that is comparable => \"boolean, numeric, string, pointer, channel, and interface types, and structs or arrays that contain only those types\" ValueType can be of any type, including custom structs or other maps use interface{} as your ValueType to have the map's valueType be of anything","title":"Creating a Map"},{"location":"collections/maps/#reading-and-writing-map-elements","text":"Like other languages, one can directly read, write, and delete values from Go maps. 1 2 3 4 5 6 7 //Setting Map Elements cardMap [ \"ace\" ] = 1 cardMap [ \"jack\" ] = 11 cardMap [ \"queen\" ] = 12 cardMap [ \"king\" ] = 13 // cardMap == map[ace:1 jack:11 king:13 queen:12] Reading Map Element 1 2 j := cardMap [ \"queen\" ] // j == 12 Deleting Map Element 1 2 delete ( cardMap , \"king\" ) // cardMap == map[ace:1 jack:11 queen:12]","title":"Reading and Writing Map Elements"},{"location":"collections/maps/#map-literals","text":"Use map literals to define the initial elements in a map. 1 2 3 4 5 trafficLightMap := map [ string ] string { \"red\" : \"stop\" , \"green\" : \"go\" , \"yellow\" : \"slow\" , }","title":"Map Literals"},{"location":"collections/maps/#iterating-through-maps","text":"Similar in syntax to slice iteration, a dev can use range to iterate through the key-value pairs in a map. 1 2 3 for key , value := range exampleMap { //Process key and/or value } Can use _ in place of key or value if they aren't needed Example: 1 2 3 4 5 6 7 8 9 for key , value := range cardMap { fmt . Println ( \"Key:\" , key , \"; Value:\" , value ) } /* Console output Key: ace ; Value: 1 Key: jack ; Value: 11 Key: queen ; Value: 12 */","title":"Iterating Through Maps"},{"location":"collections/maps/#getting-a-keys-value-if-the-pair-exists","text":"There is an optional second return value when reading from a map that tells the dev if a key-value pair exists. Syntax 1 2 3 4 5 value , ok := someMap [ key ] if ! ok { //Do something if there is no key-value pair }","title":"Getting a Key's Value if the pair exists"},{"location":"collections/maps/#checking-for-key-value-existence","text":"If you don't care for retrieving the value, one can just check the existence of the key-value pair. 1 2 3 4 5 _ , ok := someMap [ key ] if ! ok { //Do something if there is no key-value pair } Example: 1 2 3 4 5 6 7 //Given: \"king\" and its value don't exist in cardMap k , ok := cardMap [ \"king\" ] if ! ok { fmt . Println ( \"king isn't there\" ) } //Output = \"king isn't there\"","title":"Checking for key-value existence"},{"location":"collections/slices/","text":"Arrays: Fixed-Sized Sample code link: ( https://repl.it/@jjoco/go-arrays ) Arrays in Go are similar to those in C-like languages. They are of fixed size and have no specific methods to use on them. Hence, they are not nearly as used as often as slices, which we will cover in the next section. But, if you want to use them, creating, reading, and writing to arrays are very similar to that in other languages. Syntax: 1 2 3 4 5 6 7 8 //Initalized via regular assignment var exampleArr [ arrSize ] elementType //Modifying array element exampleArr [ index ] = value //Literal declared with short assignment literalArr := [ n ] elementType { element1 , element2 , ... , elementN } Example 1 2 3 4 5 6 var boolArr [ 2 ] bool boolArr [ 0 ] = true //boolArr == [true false] floatArr := [ 4 ] float64 { 1.23 , 4.5 , 6.78 , 9.0 } //floatArr == [1.23 4.5 6.78 9] Slices: Dynamically-Sized Arrays Sample code link: https://repl.it/@jjoco/go-slices Slices are essentially dynamic arrays that have several useful methods and offer flexibility that arrays do not. Thus, slices are used much more often than arrays. Creating a New, Empty Slice One can create a slice similar to creating an array, but you don't specify the size at compile-time: 1 2 3 4 5 6 7 8 9 var slice0 [] int // slice0 == nil slice1 := [] int {} // slice1 == [] //This is functionally identical to slice1's declaration slice2 := make ([] int , 0 ) // slice2 == [] Use make([]elementType, len, cap) to create a slice that contains elements of type elementType whose internal array's first len elements are memory-allocated cap is an optional parameter that denotes the internal array's initial allocated size; cap == len if cap is not specified Slice Literals One can declare a slice and specifically define its elements. 1 2 3 strLiteralSlice := [] string { \"this\" , \"is\" , \"a\" , \"test\" } // strLiteralSlice = [this is a test] Reading and Writing Slice Elements Reading and writing slice elements is similar to doing so to arrays. 1 2 3 4 5 6 7 //Setting Element strLiteralSlice [ 3 ] = \"shoe\" // strLiteralSlice = [this is a shoe] //Reading Element j := strLiteralSlice [ 2 ] // j == \"a\" Slice Methods Slices have useful methods that a dev can use len(slice) => Returns length (integer) of slice cap(slice) => returns capacity (integer) of slice append(slice, newElements...) => returns a slice that contains elements from newElements added into input slice Append example 1 2 3 4 5 6 appendSlice := [] int { 3 , 4 , 1 } //\"Before Appending [3 4 1]\" appendSlice = append ( appendSlice , 23 , 21 , 43 ) appendSlice = append ( appendSlice , [] int { 3 , 2 , 1 } ... ) //\"After Appending [3 4 1 23 21 43 3 2 1]\" Notes To accumulate a slice, be mindful to have the slice be the input and output to the append function ... succeeding a slice represents unpacking the elements in that slice into arguments for the function copy(destSlice, srcSlice) => copies elements from srcSlice into destSlice; returns nothing Copy example 1 2 3 4 origSlice := [] int { 4 , 3 , 2 } copySlice := make ([] int , len ( origSlice )) copy ( copySlice , origSlice ) //\"Original Slice : [4 3 2] ; Copy Slice : [4 3 2]\"\" Iterating through a Slice You can certainly iterate through an slice like in other languages by using the slice's indices. However, one can use the range keyword to iterate through a slice's indices and elements simultaneously without using traditional array. This is very similar to using the enumerate function in Python. 1 2 3 for index , element := range exampleSlice { // Do stuff with index or element } Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 iterSlice := [] string { \"baseball\" , \"basketball\" , \"soccer\" , \"hockey\" , \"football\" } //Use if both index and element are needed for index , element := range iterSlice { fmt . Println ( \"index = \" , index ) fmt . Println ( \"element = \" , element ) } //Next two loops are the same, essentially //Use if knowing the element value is not needed for index , _ := range iterSlice { fmt . Println ( \"index = \" , index ) } for index := range iterSlice { fmt . Println ( \"index = \" , index ) } //Use the index is not needed for _ , element := range iterSlice { fmt . Println ( \"element = \" , element ) } Use _ in place of index or element for whichever is not needed Creating a Slice from an Array or Slice A slice can be created from a previously created array or index by using the following syntax. The slicing syntax is very similar to that of getting list elements via range indices in Python. Syntax exampleArrOrSlice[:end] => gets a slice of elements from beginning of exampleArrOrSlice until indexend (excluding element at index end) exampleArrOrSlice[start:] => gets a slice of elements starting from index start (inclusive) until the end of exampleArrOrSlice exampleArrOrSlice[start:end] => gets a slice of elements from exampleArrOrSlice starting from index start (inclusive) until the end index end(exclusive) Example: 1 2 3 4 5 6 7 8 9 10 intSlice := [] int { 1 , 2 , 3 , 4 , 5 , 6 } beginIntSlice := intSlice [: 2 ] // beginIntSlice == [1 2] middleIntSlice := intSlice [ 2 : 4 ] // middleIntSlice == [3 4] endIntSlice := intSlice [ 4 :] // endIntSlice == [5 6]","title":"Arrays and Slices"},{"location":"collections/slices/#arrays-fixed-sized","text":"Sample code link: ( https://repl.it/@jjoco/go-arrays ) Arrays in Go are similar to those in C-like languages. They are of fixed size and have no specific methods to use on them. Hence, they are not nearly as used as often as slices, which we will cover in the next section. But, if you want to use them, creating, reading, and writing to arrays are very similar to that in other languages. Syntax: 1 2 3 4 5 6 7 8 //Initalized via regular assignment var exampleArr [ arrSize ] elementType //Modifying array element exampleArr [ index ] = value //Literal declared with short assignment literalArr := [ n ] elementType { element1 , element2 , ... , elementN } Example 1 2 3 4 5 6 var boolArr [ 2 ] bool boolArr [ 0 ] = true //boolArr == [true false] floatArr := [ 4 ] float64 { 1.23 , 4.5 , 6.78 , 9.0 } //floatArr == [1.23 4.5 6.78 9]","title":"Arrays: Fixed-Sized"},{"location":"collections/slices/#slices-dynamically-sized-arrays","text":"Sample code link: https://repl.it/@jjoco/go-slices Slices are essentially dynamic arrays that have several useful methods and offer flexibility that arrays do not. Thus, slices are used much more often than arrays.","title":"Slices: Dynamically-Sized Arrays"},{"location":"collections/slices/#creating-a-new-empty-slice","text":"One can create a slice similar to creating an array, but you don't specify the size at compile-time: 1 2 3 4 5 6 7 8 9 var slice0 [] int // slice0 == nil slice1 := [] int {} // slice1 == [] //This is functionally identical to slice1's declaration slice2 := make ([] int , 0 ) // slice2 == [] Use make([]elementType, len, cap) to create a slice that contains elements of type elementType whose internal array's first len elements are memory-allocated cap is an optional parameter that denotes the internal array's initial allocated size; cap == len if cap is not specified","title":"Creating a New, Empty Slice"},{"location":"collections/slices/#slice-literals","text":"One can declare a slice and specifically define its elements. 1 2 3 strLiteralSlice := [] string { \"this\" , \"is\" , \"a\" , \"test\" } // strLiteralSlice = [this is a test]","title":"Slice Literals"},{"location":"collections/slices/#reading-and-writing-slice-elements","text":"Reading and writing slice elements is similar to doing so to arrays. 1 2 3 4 5 6 7 //Setting Element strLiteralSlice [ 3 ] = \"shoe\" // strLiteralSlice = [this is a shoe] //Reading Element j := strLiteralSlice [ 2 ] // j == \"a\"","title":"Reading and Writing Slice Elements"},{"location":"collections/slices/#slice-methods","text":"Slices have useful methods that a dev can use len(slice) => Returns length (integer) of slice cap(slice) => returns capacity (integer) of slice append(slice, newElements...) => returns a slice that contains elements from newElements added into input slice Append example 1 2 3 4 5 6 appendSlice := [] int { 3 , 4 , 1 } //\"Before Appending [3 4 1]\" appendSlice = append ( appendSlice , 23 , 21 , 43 ) appendSlice = append ( appendSlice , [] int { 3 , 2 , 1 } ... ) //\"After Appending [3 4 1 23 21 43 3 2 1]\" Notes To accumulate a slice, be mindful to have the slice be the input and output to the append function ... succeeding a slice represents unpacking the elements in that slice into arguments for the function copy(destSlice, srcSlice) => copies elements from srcSlice into destSlice; returns nothing Copy example 1 2 3 4 origSlice := [] int { 4 , 3 , 2 } copySlice := make ([] int , len ( origSlice )) copy ( copySlice , origSlice ) //\"Original Slice : [4 3 2] ; Copy Slice : [4 3 2]\"\"","title":"Slice Methods"},{"location":"collections/slices/#iterating-through-a-slice","text":"You can certainly iterate through an slice like in other languages by using the slice's indices. However, one can use the range keyword to iterate through a slice's indices and elements simultaneously without using traditional array. This is very similar to using the enumerate function in Python. 1 2 3 for index , element := range exampleSlice { // Do stuff with index or element } Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 iterSlice := [] string { \"baseball\" , \"basketball\" , \"soccer\" , \"hockey\" , \"football\" } //Use if both index and element are needed for index , element := range iterSlice { fmt . Println ( \"index = \" , index ) fmt . Println ( \"element = \" , element ) } //Next two loops are the same, essentially //Use if knowing the element value is not needed for index , _ := range iterSlice { fmt . Println ( \"index = \" , index ) } for index := range iterSlice { fmt . Println ( \"index = \" , index ) } //Use the index is not needed for _ , element := range iterSlice { fmt . Println ( \"element = \" , element ) } Use _ in place of index or element for whichever is not needed","title":"Iterating through a Slice"},{"location":"collections/slices/#creating-a-slice-from-an-array-or-slice","text":"A slice can be created from a previously created array or index by using the following syntax. The slicing syntax is very similar to that of getting list elements via range indices in Python. Syntax exampleArrOrSlice[:end] => gets a slice of elements from beginning of exampleArrOrSlice until indexend (excluding element at index end) exampleArrOrSlice[start:] => gets a slice of elements starting from index start (inclusive) until the end of exampleArrOrSlice exampleArrOrSlice[start:end] => gets a slice of elements from exampleArrOrSlice starting from index start (inclusive) until the end index end(exclusive) Example: 1 2 3 4 5 6 7 8 9 10 intSlice := [] int { 1 , 2 , 3 , 4 , 5 , 6 } beginIntSlice := intSlice [: 2 ] // beginIntSlice == [1 2] middleIntSlice := intSlice [ 2 : 4 ] // middleIntSlice == [3 4] endIntSlice := intSlice [ 4 :] // endIntSlice == [5 6]","title":"Creating a Slice from an Array or Slice"},{"location":"concurrency/channels/","text":"Sample code link: ( https://repl.it/@jjoco/go-channels ) Go channels is the method of communication that allows go routines to talk to each other. These are FIFO. The dev has to define the type that goes into the channel. The type can be anything: structs, maps, slices, primitives, etc. If two go routines were processes, the go channel is the bridge between them: Non-Buffered Channels By default channels are unbuffered , meaning that they will only accept sends (chan <-) if there is a corresponding receive ( <-chan ) ready to receive the sent value 1 channel := make ( chan ElementType ) Buffered Channels Buffered channels accept a limited number of values without a corresponding receiver for those values. These are much more flexible than unbuffered channels. 1 channel := make ( chan ElementType , channelSize ) Reading and Writing to Channels The <- denotes which way a value is getting written into Writing 1 channel <- writeValue - writeValue is getting written into channel Reading 1 readVar <- channel - The front of channel is getting read into declared variable readVar Non-buffered example A go routine is writing into nonBufferedChannel and has a receive in the main goroutine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 nonBuffedChannel := make ( chan string ) go func (){ nonBuffedChannel <- \"ping\" }() fmt . Println ( <- nonBuffedChannel ) fmt . Println ( \"Finished\" ) //This will not work: messages := make ( chan string ) messages <- \"no\" fmt . Println ( <- messages ) fmt . Println ( \"Done\" ) This will not run correctly because there is no immediate receiver (eg a concurrent receiver) for the send into messages Buffered examples 1 2 3 4 5 6 7 messages := make ( chan string , 2 ) messages <- \"hello there\" messages <- \"general kenobi!!\" fmt . Println ( <- messages ) fmt . Println ( <- messages ) - Strings are getting written into the messages channel and read out in a FIFO way Uni-directional Channels A function can be configured to be able to only read from a given channel or be forced to only write into a channel. This is used for type safety, and it ensures no two go routines can write to the same channel. Send-Only 1 2 3 func functionName ( sendOnlyChannel chan <- ElementType , ... ){ //This function can only write into the given channel } - The above function can only write data into sendOnlyChannel; it cannot read from the channel Receive-Only 1 2 3 func functionName ( receiveOnlyChannel <- chan ElementType , ... ){ //This function can only read from the given channel } - The above function can only read data from receiveOnlyChannel; it cannot write into the channel Example: 1 2 3 4 //ping fct can only write into pings channel func ping ( pings chan <- string , msg string ){ pings <- msg } 1 2 3 4 5 6 //pong fct can only read from pings channel and write into pongs channel func pong ( pings <- chan string , pongs chan <- string ){ msg := <- pings pongs <- msg } Main: 1 2 3 4 5 6 7 pings := make ( chan string , 1 ) pongs := make ( chan string , 1 ) ping ( pings , \"passed message\" ) pong ( pings , pongs ) fmt . Println ( <- pongs ) What is happening above: ping is writing passed message into the pings channel pong is reading passed message from pings channel and writing passed message into the pongs channel The main goroutine is reading and printing out passed message from the pongs channel Range and Close A go routine can close a channel if you're completely done with it 1 close ( channel ) Another go routine can use range to iterate through closed buffered channel 1 2 3 for elem := range channel { // Do stuff to each element in the channel } Example The below function writes intermediate products into the go channel, and closes the channel once its done. 1 2 3 4 5 6 7 8 func factorial ( n int , channel chan int ){ product := 1 for i := 1 ; i <= n ; i ++ { product *= i channel <- product } close ( channel ) } In main: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 n := 5 factorialChannel := make ( chan int , n ) go factorial ( n , factorialChannel ) for elem := range factorialChannel { fmt . Println ( elem ) } /* Console output 1 2 6 24 120 */ The main function uses range in order to iterate through all the values in the closed factorialChannel . Select A goroutine that uses select waits until it has read or written to a specified channel. Syntax: 1 2 3 4 5 6 7 8 9 10 11 12 select { //Waits until channel's front is read into readVar case readVar := <- channel : ... //Waits until writeVar is queued into channel case channel <- writeVar : ... default : ... } Notes Blocking Send/Receive: Without default, select waits until something can be read from channel or written into it Non-Blocking Send/Receive: With default, select does not wait for a send or receive case to be satisfied Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 channelSize := 3 sampleChannel := make ( chan int , channelSize ) //Starts up 3 goroutines for j := 0 ; j < channelSize ; j ++ { go countFromStartToEnd ( \"Goroutine1\" , 0 , j * 2 , j , sampleChannel ) } //Waits for all goroutines to finish before moving on numResponse := 0 for numResponse < channelSize { select { case response := <- sampleChannel : fmt . Println ( response ) numResponse ++ //Implement default for non-blocking channel receives /* default: fmt.Println(\"Nothing received yet.\") */ } }","title":"Channels"},{"location":"concurrency/channels/#non-buffered-channels","text":"By default channels are unbuffered , meaning that they will only accept sends (chan <-) if there is a corresponding receive ( <-chan ) ready to receive the sent value 1 channel := make ( chan ElementType )","title":"Non-Buffered Channels"},{"location":"concurrency/channels/#buffered-channels","text":"Buffered channels accept a limited number of values without a corresponding receiver for those values. These are much more flexible than unbuffered channels. 1 channel := make ( chan ElementType , channelSize )","title":"Buffered Channels"},{"location":"concurrency/channels/#reading-and-writing-to-channels","text":"The <- denotes which way a value is getting written into Writing 1 channel <- writeValue - writeValue is getting written into channel Reading 1 readVar <- channel - The front of channel is getting read into declared variable readVar Non-buffered example A go routine is writing into nonBufferedChannel and has a receive in the main goroutine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 nonBuffedChannel := make ( chan string ) go func (){ nonBuffedChannel <- \"ping\" }() fmt . Println ( <- nonBuffedChannel ) fmt . Println ( \"Finished\" ) //This will not work: messages := make ( chan string ) messages <- \"no\" fmt . Println ( <- messages ) fmt . Println ( \"Done\" ) This will not run correctly because there is no immediate receiver (eg a concurrent receiver) for the send into messages Buffered examples 1 2 3 4 5 6 7 messages := make ( chan string , 2 ) messages <- \"hello there\" messages <- \"general kenobi!!\" fmt . Println ( <- messages ) fmt . Println ( <- messages ) - Strings are getting written into the messages channel and read out in a FIFO way","title":"Reading and Writing to Channels"},{"location":"concurrency/channels/#uni-directional-channels","text":"A function can be configured to be able to only read from a given channel or be forced to only write into a channel. This is used for type safety, and it ensures no two go routines can write to the same channel. Send-Only 1 2 3 func functionName ( sendOnlyChannel chan <- ElementType , ... ){ //This function can only write into the given channel } - The above function can only write data into sendOnlyChannel; it cannot read from the channel Receive-Only 1 2 3 func functionName ( receiveOnlyChannel <- chan ElementType , ... ){ //This function can only read from the given channel } - The above function can only read data from receiveOnlyChannel; it cannot write into the channel Example: 1 2 3 4 //ping fct can only write into pings channel func ping ( pings chan <- string , msg string ){ pings <- msg } 1 2 3 4 5 6 //pong fct can only read from pings channel and write into pongs channel func pong ( pings <- chan string , pongs chan <- string ){ msg := <- pings pongs <- msg } Main: 1 2 3 4 5 6 7 pings := make ( chan string , 1 ) pongs := make ( chan string , 1 ) ping ( pings , \"passed message\" ) pong ( pings , pongs ) fmt . Println ( <- pongs ) What is happening above: ping is writing passed message into the pings channel pong is reading passed message from pings channel and writing passed message into the pongs channel The main goroutine is reading and printing out passed message from the pongs channel","title":"Uni-directional Channels"},{"location":"concurrency/channels/#range-and-close","text":"A go routine can close a channel if you're completely done with it 1 close ( channel ) Another go routine can use range to iterate through closed buffered channel 1 2 3 for elem := range channel { // Do stuff to each element in the channel } Example The below function writes intermediate products into the go channel, and closes the channel once its done. 1 2 3 4 5 6 7 8 func factorial ( n int , channel chan int ){ product := 1 for i := 1 ; i <= n ; i ++ { product *= i channel <- product } close ( channel ) } In main: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 n := 5 factorialChannel := make ( chan int , n ) go factorial ( n , factorialChannel ) for elem := range factorialChannel { fmt . Println ( elem ) } /* Console output 1 2 6 24 120 */ The main function uses range in order to iterate through all the values in the closed factorialChannel .","title":"Range and Close"},{"location":"concurrency/channels/#select","text":"A goroutine that uses select waits until it has read or written to a specified channel. Syntax: 1 2 3 4 5 6 7 8 9 10 11 12 select { //Waits until channel's front is read into readVar case readVar := <- channel : ... //Waits until writeVar is queued into channel case channel <- writeVar : ... default : ... } Notes Blocking Send/Receive: Without default, select waits until something can be read from channel or written into it Non-Blocking Send/Receive: With default, select does not wait for a send or receive case to be satisfied Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 channelSize := 3 sampleChannel := make ( chan int , channelSize ) //Starts up 3 goroutines for j := 0 ; j < channelSize ; j ++ { go countFromStartToEnd ( \"Goroutine1\" , 0 , j * 2 , j , sampleChannel ) } //Waits for all goroutines to finish before moving on numResponse := 0 for numResponse < channelSize { select { case response := <- sampleChannel : fmt . Println ( response ) numResponse ++ //Implement default for non-blocking channel receives /* default: fmt.Println(\"Nothing received yet.\") */ } }","title":"Select"},{"location":"concurrency/goroutines/","text":"Sample code link: ( https://repl.it/@jjoco/go-routines ) Go's concurrency features are one of its main selling points over its competitors. Reading and writing concurrent programs is very easy. The \"threads\" in Go \"go routines\", and these are lightweight threads with small memory overhead. For example, a machine can run thousands of threads at a time, but that same machine can run millions of go routines. In addition, there is no need to import an extraneous package since concurrency is a core, primitive feature of the languages. Go routines are functions that run concurrently from whichever function calls it. These are somewhat analogous to threads of other languages, though each is implemented differently under the hood. To starting a new goroutine, use the go keyword 1 go functionName ( args ) Example: 1 2 3 4 5 6 func countFromStartToEnd ( name string , start int , end int , incr int ){ for i := start ; i < end ; i += incr { fmt . Println ( name , \" i = \" , i ) time . Sleep ( time . Millisecond ) } } Main function: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 go countFromStartToEnd ( \"Goroutine1\" , 0 , 5 , 1 ) go countFromStartToEnd ( \"Goroutine2\" , 0 , 5 , 1 ) countFromStartToEnd ( \"Main\" , 0 , 5 , 1 ) time . Sleep ( 5 * time . Second ) fmt . Println ( \"Finished\" ) /* Sample console output: Main i = 0 Goroutine2 i = 0 Goroutine1 i = 0 Goroutine2 i = 1 Main i = 1 Goroutine1 i = 1 Main i = 2 Goroutine2 i = 2 Goroutine1 i = 2 Goroutine1 i = 3 Goroutine2 i = 3 Main i = 3 Goroutine1 i = 4 Goroutine2 i = 4 Main i = 4 Finished */ - Function calls without the go keyword will be ran in the current goroutine","title":"Goroutines"},{"location":"pseudo-oop/interfaces/","text":"Sample code link: ( https://repl.it/@jjoco/go-interfaces ) Writing and Implementing Interfaces Interfaces are method blueprints and follow the syntax: 1 2 3 4 5 6 7 type InterfaceName interface { method1 () returnType1 method2 () returnType2 . . . } The following Shape interface defines two method signatures. 1 2 3 4 type Shape interface { getArea () float64 getDimensions () [] float64 } Structs can implement those method signatures, eg Rectangle and Circle. 1 2 3 4 5 6 7 8 9 10 11 12 13 /*Rectangle Implements Shape methods*/ type Rectangle struct { width float64 height float64 } func ( rect Rectangle ) getArea () float64 { return rect . width * rect . height } func ( rect Rectangle ) getDimensions () [] float64 { return [] float64 { rect . width , rect . height } } 1 2 3 4 5 6 7 8 9 10 11 12 /*Circle Implements Shape methods*/ type Circle struct { radius float64 } func ( circle Circle ) getArea () float64 { return math . Pi * math . Pow ( circle . radius , 2 ) } func ( circle Circle ) getDimensions () [] float64 { return [] float64 { circle . radius } } Though it's not immediately obvious, having these two structs define the Shape interface methods would be useful if a function's parameter is of the Shape interface. 1 2 3 4 5 6 7 func PrintShapeArea ( shape Shape ){ fmt . Println ( \"Shape Area = \" , shape . getArea ()) } func PrintShapeDimensions ( shape Shape ){ fmt . Println ( \"Shape Dimensions\" , shape . getDimensions ()) } So, instead of having a print function for each struct, there can be one print function that accepts the interface that each struct implements. This is for code cogency and to reduce redundant copy/paste code. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 rect := Rectangle { 2 , 4 } circle := Circle { 3 } PrintShapeDimensions ( rect ) // \"Shape Dimensions [2 4]\" PrintShapeDimensions ( circle ) // \"Shape Dimensions [3]\" PrintShapeArea ( rect ) // \"Shape Area = 8\" PrintShapeArea ( circle ) // \"Shape Area = 25\" Let's go through a more practical example. Let's say we have a black-box function that takes the io.Reader interface (from io package) as a parameter 1 2 3 func handleReader ( r io . Reader ){ ... } Structs that implement io.Reader must implement the Read(p []byte) (n int, err error) method, such as *os.File and *bytes.Buffer Since these structs have the Read method and the handleReader function only cares that the input struct implements the Read method, handleReader can handle both *os.File and *bytes.Buffer inputs without compilation error. Of course, there are many more structs that implement the io.Reader interface, and handleReader can handle inputs of each struct without compilation error. Empty Interface An empty interface contains zero methods. Since every type implements at least zero methods, the empty interface can be used as an any type, if the developer uncertain about the types of a function, map valueType, etc. For example, any map, slice, struct implement at least zero methods; thus, they implement the empty interface. Examples: Empty Interface as a ValueType 1 2 3 4 5 6 7 sampleMap := make ( map [ string ] interface {}) /*The next two pushes to the map are completely valid since the ValueType is an empty interface*/ sampleMap [ \"hello\" ] = \"there\" sampleMap [ \"brooklynn\" ] = 99 //sampleMap == map[brooklynn:99 hello:there] In the above example, since strings and integers implement at least zero methods, they implement the empty interface, which allow each type to be added into sampleMap Empty Interface as a function parameter type 1 2 3 4 5 6 7 func printVariable ( input interface {}){ fmt . Println ( input ) } // printVariable(\"hello\") Output = \"hello\" // printVariable(124553) Output = \"124553\" // printVariable(1.034) Output = \"1.034\" Similar to the reasoning above, since strings, floats, and integers have at least zero methods, they implement the empty interface, allowing each to be an input to the printVariable function.","title":"Interfaces"},{"location":"pseudo-oop/interfaces/#writing-and-implementing-interfaces","text":"Interfaces are method blueprints and follow the syntax: 1 2 3 4 5 6 7 type InterfaceName interface { method1 () returnType1 method2 () returnType2 . . . } The following Shape interface defines two method signatures. 1 2 3 4 type Shape interface { getArea () float64 getDimensions () [] float64 } Structs can implement those method signatures, eg Rectangle and Circle. 1 2 3 4 5 6 7 8 9 10 11 12 13 /*Rectangle Implements Shape methods*/ type Rectangle struct { width float64 height float64 } func ( rect Rectangle ) getArea () float64 { return rect . width * rect . height } func ( rect Rectangle ) getDimensions () [] float64 { return [] float64 { rect . width , rect . height } } 1 2 3 4 5 6 7 8 9 10 11 12 /*Circle Implements Shape methods*/ type Circle struct { radius float64 } func ( circle Circle ) getArea () float64 { return math . Pi * math . Pow ( circle . radius , 2 ) } func ( circle Circle ) getDimensions () [] float64 { return [] float64 { circle . radius } } Though it's not immediately obvious, having these two structs define the Shape interface methods would be useful if a function's parameter is of the Shape interface. 1 2 3 4 5 6 7 func PrintShapeArea ( shape Shape ){ fmt . Println ( \"Shape Area = \" , shape . getArea ()) } func PrintShapeDimensions ( shape Shape ){ fmt . Println ( \"Shape Dimensions\" , shape . getDimensions ()) } So, instead of having a print function for each struct, there can be one print function that accepts the interface that each struct implements. This is for code cogency and to reduce redundant copy/paste code. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 rect := Rectangle { 2 , 4 } circle := Circle { 3 } PrintShapeDimensions ( rect ) // \"Shape Dimensions [2 4]\" PrintShapeDimensions ( circle ) // \"Shape Dimensions [3]\" PrintShapeArea ( rect ) // \"Shape Area = 8\" PrintShapeArea ( circle ) // \"Shape Area = 25\" Let's go through a more practical example. Let's say we have a black-box function that takes the io.Reader interface (from io package) as a parameter 1 2 3 func handleReader ( r io . Reader ){ ... } Structs that implement io.Reader must implement the Read(p []byte) (n int, err error) method, such as *os.File and *bytes.Buffer Since these structs have the Read method and the handleReader function only cares that the input struct implements the Read method, handleReader can handle both *os.File and *bytes.Buffer inputs without compilation error. Of course, there are many more structs that implement the io.Reader interface, and handleReader can handle inputs of each struct without compilation error.","title":"Writing and Implementing Interfaces"},{"location":"pseudo-oop/interfaces/#empty-interface","text":"An empty interface contains zero methods. Since every type implements at least zero methods, the empty interface can be used as an any type, if the developer uncertain about the types of a function, map valueType, etc. For example, any map, slice, struct implement at least zero methods; thus, they implement the empty interface. Examples: Empty Interface as a ValueType 1 2 3 4 5 6 7 sampleMap := make ( map [ string ] interface {}) /*The next two pushes to the map are completely valid since the ValueType is an empty interface*/ sampleMap [ \"hello\" ] = \"there\" sampleMap [ \"brooklynn\" ] = 99 //sampleMap == map[brooklynn:99 hello:there] In the above example, since strings and integers implement at least zero methods, they implement the empty interface, which allow each type to be added into sampleMap Empty Interface as a function parameter type 1 2 3 4 5 6 7 func printVariable ( input interface {}){ fmt . Println ( input ) } // printVariable(\"hello\") Output = \"hello\" // printVariable(124553) Output = \"124553\" // printVariable(1.034) Output = \"1.034\" Similar to the reasoning above, since strings, floats, and integers have at least zero methods, they implement the empty interface, allowing each to be an input to the printVariable function.","title":"Empty Interface"},{"location":"pseudo-oop/methods/","text":"Sample code link: ( https://repl.it/@jjoco/go-methods ) Writing and Using Methods These are analogous to class methods in OOP languages 1 2 3 func ( receiver ReceiverType ) methodName ( args ) returnType { //Do stuff here } Essentially, methods are functions that work for specific structs. Let's say I have the following two structs defined. 1 2 3 4 type Coordinate struct { x float64 y float64 } 1 2 3 4 type Vector struct { start Coordinate end Coordinate } The following function works for only Vector structs: 1 2 3 func ( vec Vector ) CalculateLength () float64 { return math . Sqrt ( math . Pow (( vec . end . x - vec . start . x ), 2 ) + math . Pow (( vec . end . y - vec . start . y ), 2 )) } In main, I can call the struct's method like calling class methods in other OOP languages via .functionName() : 1 2 3 4 start := Coordinate { 1 , 1 } end := Coordinate { 7 , 9 } vector := Vector { start , end } //vector.CalculateLength() == \"10\" Pointer Receivers Let's say I want a method that directly changes the fields within my receiver. You would use pointer receiver syntax, like the following: 1 2 3 func ( receiver * ReceiverType ) MethodName ( args ) returnType { //Do stuff here } Unlike traditional pointer syntax, the dev does not have to dereference the input pointer in order to modify the input struct variable, eg: 1 2 3 4 func ( vec * Vector ) SetStartEnd ( start Coordinate , end Coordinate ){ vec . start = start vec . end = end } Calling function: 1 2 vector . SetStartEnd ( Coordinate { 3 , 4 }, Coordinate { 0 , 0 }) //\"Vector Length = 5\" According to several sources, \"In general, all methods on a given type should have either value or pointer receivers, but not a mixture of both.\" So, if we modified the CalculateLength function from earlier: 1 2 3 func ( vec * Vector ) CalculateLength () float64 { return math . Sqrt ( math . Pow (( vec . end . x - vec . start . x ), 2 ) + math . Pow (( vec . end . y - vec . start . y ), 2 )) } Keep in mind that not using pointer receiver syntax would make a copy of the input struct variable. Since we're using a pointer receiver, we're only using the struct variable's address, reducing potential time and memory overhead.","title":"Methods"},{"location":"pseudo-oop/methods/#writing-and-using-methods","text":"These are analogous to class methods in OOP languages 1 2 3 func ( receiver ReceiverType ) methodName ( args ) returnType { //Do stuff here } Essentially, methods are functions that work for specific structs. Let's say I have the following two structs defined. 1 2 3 4 type Coordinate struct { x float64 y float64 } 1 2 3 4 type Vector struct { start Coordinate end Coordinate } The following function works for only Vector structs: 1 2 3 func ( vec Vector ) CalculateLength () float64 { return math . Sqrt ( math . Pow (( vec . end . x - vec . start . x ), 2 ) + math . Pow (( vec . end . y - vec . start . y ), 2 )) } In main, I can call the struct's method like calling class methods in other OOP languages via .functionName() : 1 2 3 4 start := Coordinate { 1 , 1 } end := Coordinate { 7 , 9 } vector := Vector { start , end } //vector.CalculateLength() == \"10\"","title":"Writing and Using Methods"},{"location":"pseudo-oop/methods/#pointer-receivers","text":"Let's say I want a method that directly changes the fields within my receiver. You would use pointer receiver syntax, like the following: 1 2 3 func ( receiver * ReceiverType ) MethodName ( args ) returnType { //Do stuff here } Unlike traditional pointer syntax, the dev does not have to dereference the input pointer in order to modify the input struct variable, eg: 1 2 3 4 func ( vec * Vector ) SetStartEnd ( start Coordinate , end Coordinate ){ vec . start = start vec . end = end } Calling function: 1 2 vector . SetStartEnd ( Coordinate { 3 , 4 }, Coordinate { 0 , 0 }) //\"Vector Length = 5\" According to several sources, \"In general, all methods on a given type should have either value or pointer receivers, but not a mixture of both.\" So, if we modified the CalculateLength function from earlier: 1 2 3 func ( vec * Vector ) CalculateLength () float64 { return math . Sqrt ( math . Pow (( vec . end . x - vec . start . x ), 2 ) + math . Pow (( vec . end . y - vec . start . y ), 2 )) } Keep in mind that not using pointer receiver syntax would make a copy of the input struct variable. Since we're using a pointer receiver, we're only using the struct variable's address, reducing potential time and memory overhead.","title":"Pointer Receivers"},{"location":"pseudo-oop/structs/","text":"Sample code link: https://repl.it/@jjoco/go-structs Structs are analogous to classes in OOP languages. These are your user-defined types with their own fields. Declaring a Struct Use type and struct to declare a blueprint of your struct. 1 2 3 4 5 6 7 type TypeName struct { field1 field1Type field2 field2Type . . . } Syntax notes: Use of struct keyword instead of = when making a new type No classes or objects in Go No colon between field name and its type Can declare outside calling file Fortunately, one can declare a struct outside of a function that declares one without any extra import syntax, as long as they fall under the same package. 1 2 3 4 5 6 7 8 9 /*Declared in shape.go*/ type Rectangle struct { width int height int } type Circle struct { radius float64 } Using a Struct Similar to creating a new class instance in OOP languages, a dev can create a new variable of your customized struct without extra keywords. Syntax 1 2 3 4 5 6 7 /*Declaring new type variable*/ var structDefault StructName var structCustom1 StructName = StructName { args } var structCustom2 = StructName { args } /*Short Assignment*/ structShort := StructName { args } Syntax notes: No use of new keyword Use of curly brackets {} instead of parentheses () No colons when declaring type Fields within struct variable are initialized to their zero values without explicit assigning Examples: No input parameters Fields within structs are zero-valued, if not defined at compile-time. 1 2 3 defaultRect := Rectangle {} // Output = \"Rectangle object: {0 0}\" // \"Width = 0; Height = 0\" With input parameters 1 2 3 customRect := Rectangle { 2 , 4 } // Output = \"Rectangle object: {2 4}\" // \"Width = 2; Height = 4\" With input parameters specifically defined 1 2 3 4 5 6 7 8 9 10 11 customRect2 := Rectangle { height : 2 , width : 4 } // Output = \"Rectangle object: {4 2}\" // \"Width = 4; Height = 2\" defaultCircle := Circle {} //Output = \"Circle Object: {0}\" // \"Radius = 0.000000\" customCircle := Circle { 4 } //Output = \"Circle Object: {4}\" // \"Radius = 4.000000\" Pointers and Structs A dev can use a struct pointer similarly to any other pointer. They function similarly as well, as shown in the following Pass by Value and Pass by Pointer comparison. Pass By Value 1 2 3 4 5 /*Changes input rectangle's dimensions to specified dimensions*/ func changeRectByValue ( rect Rectangle , width int , height int ){ rect . width = width rect . height = height } 1 2 3 4 /*Pass By Value Call*/ defaultRect = Rectangle {} changeRectByValue ( defaultRect , 3 , 4 ) //Output = \"Default Rect after change by value {0 0}\" Pass By Pointer 1 2 3 4 5 /*Changes input rectangle's dimensions to specified dimensions*/ func changeRectByPointer ( rectPtr * Rectangle , width int , height int ){ ( * rectPtr ). width = width ( * rectPtr ). height = height } 1 2 3 4 /*Pass by Pointer Call*/ defaultRect = Rectangle {} changeRectByPointer ( & defaultRect , 3 , 4 ) //Output = \"Default Rect after change by pointer {3 4}\"","title":"Structs"},{"location":"pseudo-oop/structs/#declaring-a-struct","text":"Use type and struct to declare a blueprint of your struct. 1 2 3 4 5 6 7 type TypeName struct { field1 field1Type field2 field2Type . . . } Syntax notes: Use of struct keyword instead of = when making a new type No classes or objects in Go No colon between field name and its type Can declare outside calling file Fortunately, one can declare a struct outside of a function that declares one without any extra import syntax, as long as they fall under the same package. 1 2 3 4 5 6 7 8 9 /*Declared in shape.go*/ type Rectangle struct { width int height int } type Circle struct { radius float64 }","title":"Declaring a Struct"},{"location":"pseudo-oop/structs/#using-a-struct","text":"Similar to creating a new class instance in OOP languages, a dev can create a new variable of your customized struct without extra keywords. Syntax 1 2 3 4 5 6 7 /*Declaring new type variable*/ var structDefault StructName var structCustom1 StructName = StructName { args } var structCustom2 = StructName { args } /*Short Assignment*/ structShort := StructName { args } Syntax notes: No use of new keyword Use of curly brackets {} instead of parentheses () No colons when declaring type Fields within struct variable are initialized to their zero values without explicit assigning Examples:","title":"Using a Struct"},{"location":"pseudo-oop/structs/#no-input-parameters","text":"Fields within structs are zero-valued, if not defined at compile-time. 1 2 3 defaultRect := Rectangle {} // Output = \"Rectangle object: {0 0}\" // \"Width = 0; Height = 0\"","title":"No input parameters"},{"location":"pseudo-oop/structs/#with-input-parameters","text":"1 2 3 customRect := Rectangle { 2 , 4 } // Output = \"Rectangle object: {2 4}\" // \"Width = 2; Height = 4\"","title":"With input parameters"},{"location":"pseudo-oop/structs/#with-input-parameters-specifically-defined","text":"1 2 3 4 5 6 7 8 9 10 11 customRect2 := Rectangle { height : 2 , width : 4 } // Output = \"Rectangle object: {4 2}\" // \"Width = 4; Height = 2\" defaultCircle := Circle {} //Output = \"Circle Object: {0}\" // \"Radius = 0.000000\" customCircle := Circle { 4 } //Output = \"Circle Object: {4}\" // \"Radius = 4.000000\"","title":"With input parameters specifically defined"},{"location":"pseudo-oop/structs/#pointers-and-structs","text":"A dev can use a struct pointer similarly to any other pointer. They function similarly as well, as shown in the following Pass by Value and Pass by Pointer comparison. Pass By Value 1 2 3 4 5 /*Changes input rectangle's dimensions to specified dimensions*/ func changeRectByValue ( rect Rectangle , width int , height int ){ rect . width = width rect . height = height } 1 2 3 4 /*Pass By Value Call*/ defaultRect = Rectangle {} changeRectByValue ( defaultRect , 3 , 4 ) //Output = \"Default Rect after change by value {0 0}\" Pass By Pointer 1 2 3 4 5 /*Changes input rectangle's dimensions to specified dimensions*/ func changeRectByPointer ( rectPtr * Rectangle , width int , height int ){ ( * rectPtr ). width = width ( * rectPtr ). height = height } 1 2 3 4 /*Pass by Pointer Call*/ defaultRect = Rectangle {} changeRectByPointer ( & defaultRect , 3 , 4 ) //Output = \"Default Rect after change by pointer {3 4}\"","title":"Pointers and Structs"}]}